<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>5. Data Driving Selenium Tests</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h1><a name="5. Data Driving Selenium Tests">5. Data Driving Selenium Tests</a></h1>One of the most important considerations when writing Selenium tests is how to set up the data that the tests require. If you are purely running your Selenium tests against <em class="italic">localhost</em> this is actually reasonably straightforward. Since the Selenium tests are running in the same JVM as the Grails application under test, the tests have direct access to the application's domain objects and can set up data very easily.<p class="paragraph"/><blockquote class="warning">
Data-driving using direct access to application domain classes is <strong class="bold">not</strong> appropriate when running Selenium tests against a remote application, i.e. when <code>selenium.remote = true</code> is set. In that case the Selenium tests and the application are running in separate JVMs.
</blockquote><p class="paragraph"/>For example:<p class="paragraph"/><div class="code"><pre>void testSongsAppearInList() &#123;
    Song.withTransaction &#123;
        <span class="java&#45;keyword">new</span> Song(title: <span class="java&#45;quote">"Heads Will Roll"</span>, artist: <span class="java&#45;quote">"Yeah Yeah Yeahs"</span>).save(failOnError: <span class="java&#45;keyword">true</span>)
        <span class="java&#45;keyword">new</span> Song(title: <span class="java&#45;quote">"Twilight Galaxy"</span>, artist: <span class="java&#45;quote">"Metric"</span>).save(failOnError: <span class="java&#45;keyword">true</span>)
        <span class="java&#45;keyword">new</span> Song(title: <span class="java&#45;quote">"I'm Confused"</span>, artist: <span class="java&#45;quote">"Handsome Furs"</span>).save(failOnError: <span class="java&#45;keyword">true</span>)
    &#125;
    selenium.open <span class="java&#45;quote">"$contextPath/song/list"</span>
    assertEquals 3, selenium.getXpathCount(<span class="java&#45;quote">"//table/tbody/tr"</span>)
&#125;</pre></div><p class="paragraph"/>Using a <code>withTransaction</code> block ensures you won't have problems with lazy-loading, failed data setup will get rolled back immediately and the data will be committed to the database before the browser hits the page. I also find that errors are reported better when data setup does fail.<p class="paragraph"/>Data can also be created in the <code>setUp</code> method of the test case in exactly the same way.<p class="paragraph"/><h3>Using the Build Test Data plugin</h3><p class="paragraph"/>The <a href="http://grails.org/plugin/build-test-data" target="blank">Build Test Data plugin</a> is very useful once your domain model goes beyond a trivial level of complexity and it can also be used directly in Selenium tests:<p class="paragraph"/><div class="code"><pre>void testSongsAppearInList() &#123;
    Song.withTransaction &#123;
        3.times &#123;
            Song.build() // assume we have some nice defaults in TestDataConfig.groovy
        &#125;
    &#125;
    selenium.open <span class="java&#45;quote">"$contextPath/song/list"</span>
    assertEquals 3, selenium.getXpathCount(<span class="java&#45;quote">"//table/tbody/tr"</span>)
&#125;</pre></div><p class="paragraph"/>An alternative to the build test data is the <a href="http://grails.org/plugin/fixtures" target="blank">Fixtures plugin</a> which can also be used directly from Selenium tests.<p class="paragraph"/><h3>Tearing data down</h3><p class="paragraph"/>The difficulty with data-driving Selenium tests like this is that unlike integration tests they are not run in a transactional context. Even if they were the problem would still arise as data modifications made using the browser (e.g. submitting an update form) would not be part of the <em class="italic">same</em> transaction that the test runs in. To keep your tests isolated from one another it is <em class="italic">critical</em> to use <code>tearDown</code> effectively to prevent data from one test 'bleeding over' into the next. With the examples above I could implement <code>tearDown</code> like this:<p class="paragraph"/><div class="code"><pre>void tearDown() &#123;
    <span class="java&#45;keyword">super</span>.tearDown()
    Song.withTransaction &#123;
        Song.list()&#42;.delete()
    &#125;
&#125;</pre></div><p class="paragraph"/>Again, the <code>withTransaction</code> block ensures that the deletes are flushed and committed to the database and that any problems deleting will get reported right away causing the test to fail.<p class="paragraph"/><h3>Test-wide data setup in JUnit 4 tests</h3><p class="paragraph"/>In Grails 1.3+ you can have set up and tear down methods that run before and after <em class="italic">all</em> tests in a class rather than each individual test by using <code>static void</code> methods with <a href="http://www.junit.org/apidocs/org/junit/BeforeClass.html" target="blank">&#64;BeforeClass</a> and <a href="http://www.junit.org/apidocs/org/junit/AfterClass.html" target="blank">&#64;AfterClass</a> annotations. Obviously this will not be appropriate for all test cases. In particular any tests that create or edit data may well have to use a per-method tear down. However, when appropriate it can be a good optimization.<p class="paragraph"/><h3>The Hibernate session</h3><p class="paragraph"/>There is a situation in which you need to be aware of the Hibernate session when data driving tests. If you are:
<ul class="star">
<li>Setting up data in <em class="italic">setUp</em> or the start of a test</li>
<li>Then using Selenium to modify that data (e.g. by using an edit page)</li>
<li>Then deleting the data in _tearDown_</li>
</ul><p class="paragraph"/>You need to wrap the initial creation of the data in a <em class="italic">withNewSession</em> block. For example:<p class="paragraph"/><div class="code"><pre>def songId<p class="paragraph"/>void setUp() &#123;
	<span class="java&#45;keyword">super</span>.setUp()
	Song.withNewSession &#123;
		songId = Song.build(title: <span class="java&#45;quote">"Desert Song"</span>, artist: <span class="java&#45;quote">"Edward Sharpe &#38; the Magnetic Zeros"</span>).id
	&#125;
&#125;<p class="paragraph"/>void testEditingData() &#123;
	def editPage = EditSongPage.open(id)
	// &#8230; manipulate and save the data
&#125;<p class="paragraph"/>void tearDown() &#123;
	<span class="java&#45;keyword">super</span>.tearDown()
	Song.withTransaction &#123;
		Song.list()&#42;.delete() // would <span class="java&#45;keyword">throw</span> an exception <span class="java&#45;keyword">if</span> the object it tries to delete is stale
	&#125;
&#125;</pre></div><p class="paragraph"/>The reason is that creating the record stores it in the Hibernate session on the thread used by the test. Selenium then makes the application modify the data <strong class="bold">in a different session</strong> after which your test will find the object in the test's session is stale when it tries to delete it. Creating the data in a new session means that when the deletion happens the object is not in the session at all.
	</body>
</html>