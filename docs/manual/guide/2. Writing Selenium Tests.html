<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>2. Writing Selenium Tests</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		<h1><a name="2. Writing Selenium Tests">2. Writing Selenium Tests</a></h1>Selenium tests should be placed under the <code>test/selenium</code> directory. As with other test types you can use packages to group your tests if you wish.<p class="paragraph"/><blockquote class="note">
You should <em class="italic">not</em> extend any of the base test classes in the Selenium API such as
<code><a href="http://release.seleniumhq.org/selenium-remote-control/1.0-beta-2/doc/java/com/thoughtworks/selenium/SeleneseTestCase.html" target="blank">SeleneseTestCase</a></code>
or <code><a href="http://release.seleniumhq.org/selenium-remote-control/1.0-beta-2/doc/java/com/thoughtworks/selenium/GroovySeleneseTestCase.html" target="blank">GroovySeleneseTestCase</a></code>
as these tests will attempt to create a separate Selenium instance (and open another browser window) for every single
test! The plugin starts a Selenium instance for you when <code>grails test-app</code> runs the functional test phase. Your tests
simply need to connect to that running Selenium instance.
</blockquote><p class="paragraph"/>There are several options available for writing Selenium tests:
<ol>
<li>guide:2.1 Using the SeleniumTest Mixin</li>
<li>guide:2.2 Extending GrailsSeleniumTestCase</li>
<li>guide:2.3 The Page Object Pattern</li>
</ol><p class="paragraph"/>You are not limited to writing Selenium tests as JUnit test cases.
<ol>
<li>guide:2.4 Using Other Testing Frameworks</li>
</ol><p class="paragraph"/><h2><a name="2.1. Using The SeleniumTest Mixin">2.1. Using The SeleniumTest Mixin</a></h2>The simplest way to write Selenium tests is to create a class that extends <code>GroovyTestCase</code> and add the <code>SeleniumTest</code>
mixin that the plugin provides. The mixin class makes several properties and methods available, the most crucial of
which is the running <code>Selenium</code> instance. For example:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugins.selenium.SeleniumTest<p class="paragraph"/>@Mixin(SeleniumTest)
class HomepageTests <span class="java&#45;keyword">extends</span> GroovyTestCase &#123;
    void testHomepageLoads() &#123;
        selenium.open <span class="java&#45;quote">"$contextPath/"</span>
        assertTrue selenium.isTextPresent(<span class="java&#45;quote">"Welcome to Grails"</span>)
    &#125;
&#125;</pre></div><p class="paragraph"/>References to the <code>selenium</code> property in the test will get the running <code>Selenium</code> instance from the mixin class. You
might also notice the <code>contextPath</code> property used in the <code>open</code> call. This is also provided by the mixin class and is a
reference to the context that your application is running under.<p class="paragraph"/><h3>Properties and methods of the SeleniumTest mixin</h3>
<table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Name</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>selenium</td><td>The running Selenium instance that is used to interact with the browser.</td></tr><tr class="table-even"><td>contextPath</td><td>The URL context path of the application under test. This needs to be prepended to all URLs you open with selenium.</td></tr><tr class="table-odd"><td>config</td><td>The Selenium configuration object.</td></tr><tr class="table-even"><td>waitFor(String, Closure)</td><td>A method that allows your test to wait for some condition to become true.</td></tr></table><p class="paragraph"/><h3>Using the waitFor method</h3>
The <code>waitFor</code> method is particularly useful when testing rich UIs where clicks do not cause the entire page to refresh
but instead trigger AJAX actions that update portions of the page asynchronously. For example to click a button then
wait for some text to appear before proceeding:<p class="paragraph"/><div class="code"><pre>selenium.click(<span class="java&#45;quote">"myButton"</span>)
waitFor(<span class="java&#45;quote">"Clicking myButtonId should have updated myDiv via AJAX"</span>) &#123;
    selenium.getText(<span class="java&#45;quote">"myDiv"</span>) == <span class="java&#45;quote">"Some value"</span>
&#125;</pre></div><p class="paragraph"/>The <code>waitFor</code> method will fail if the expected condition does not hold true after the default timeout specified with
<code>selenium.defaultTimeout</code> in your <code>SeleniumConfig.groovy</code> file or 60 seconds if you have not specified a value.<p class="paragraph"/>The message argument is optional but greatly assists in analysing test failures so it is recommended that you always
provide it.
<h2><a name="2.2. Extending GrailsSeleniumTestCase">2.2. Extending GrailsSeleniumTestCase</a></h2>Instead of using the <code>SeleniumTest</code> mixin you can extend <code>grails.plugins.selenium.GrailsSeleniumTestCase</code> which provides
everything the mixin does with some additional capabilities. Firstly you can use some of the more advanced assertions
provided by the <code><a href="http://release.seleniumhq.org/selenium-remote-control/1.0-beta-2/doc/java/com/thoughtworks/selenium/SeleneseTestBase.html" target="blank">SeleneseTestBase</a></code>
class as well as the various <code>verify</code> methods, the <code>seleniumEquals</code> method, etc. See the documentation for <code>SeleneseTestBase</code> for
details.<p class="paragraph"/><h3>Using assert, verify and waitFor convenience methods</h3>
Extending <code>GrailsSeleniumTestCase</code> enables you to directly <em class="italic">assert, verify</em> or <em class="italic">waitFor</em> certain Selenium conditions. Any
<code><a href="http://release.seleniumhq.org/selenium-remote-control/1.0-beta-2/doc/java/com/thoughtworks/selenium/Selenium.html" target="blank">Selenium</a></code>
method starting with <em class="italic">is</em> can be used as a boolean assertion by replacing the <em class="italic">is</em> with <em class="italic">assert, verify</em> or <em class="italic">waitFor</em> in
the method call. Likewise any <code>Selenium</code> method starting with <em class="italic">get</em> can be used as an equality assertion. The following
table gives some examples:<p class="paragraph"/><table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Without GrailsSeleniumTestCase</strong></th><th><strong class="bold">With GrailsSeleniumTestCase</strong></th></tr><tr class="table-odd"><td>assertTrue selenium.isTextPresent("Welcome to Grails")</td><td>assertTextPresent("Welcome to Grails")</td></tr><tr class="table-even"><td>verifyTrue selenium.isVisible("myElement")</td><td>verifyVisible("myElement")</td></tr><tr class="table-odd"><td>waitFor { selenium.isAlertPresent() }</td><td>waitForAlertPresent()</td></tr><tr class="table-even"><td>assertEquals("Expected text", selenium.getText("myElement"))</td><td>assertText("Expected text", "myElement")</td></tr><tr class="table-odd"><td>waitFor { selenium.getXpathCount("//ul/li") == 3 }</td><td>waitForXpathCount 3, "//ul/li"</td></tr></table><p class="paragraph"/>You can also use <em class="italic">assertNot&#42;, verifyNot&#42;</em> and <em class="italic">waitForNot&#42;</em> to test negated conditions.<p class="paragraph"/>Currently there is no way to pass message arguments to these convenience methods, although this will hopefully be added
in a future version of the plugin.
<h2><a name="2.3. Using The Page Object Pattern">2.3. Using The Page Object Pattern</a></h2>Whether using the <code>SeleniumTest</code> mixin or extending <code>GrailsSeleniumTestCase</code> your tests interact directly with Selenium. Once you go beyond a handful of simple tests this can make your tests difficult to maintain as they are dealing with the details of the page. Some of the problems with this approach include:
<ul class="star">
<li>Page element locators (whether XPath, CSS, element Ids, etc.) are repeated throughout the tests and therefore require you to hunt out instances if you change the page structure.</li>
<li>Multiple Selenium commands representing a single <em class="italic">logical</em> action may be repeated in several tests or grouped together into utility classes that can easily get out of control and turn into 'God Objects'.</li>
</ul><p class="paragraph"/>To truly decouple the functional intent of your tests from the raw Selenium interactions you can write 'page objects'. A page object represents a particular page within your application and defines methods and properties that allow your tests to interact with the page. The tests interact with the page objects, not directly with Selenium so they operate at a layer of abstraction from the fine details of the page. The advantages of this pattern include:
<ul class="star">
<li>Details of page can be refactored more easily as changes only need to be reflected in the page object, not the tests themselves.</li>
<li>Complex interactions can be modelled in methods on the page object, meaning they can be reused in multiple tests.</li>
<li>Navigation actions can be modelled as page object methods that return instances of other page objects representing the user's journey through the application.</li>
<li>Page objects are very easy to write, can be expanded as necessary and greatly enhance the simplicity and readability of your tests.</li>
</ul><p class="paragraph"/>When using the page object pattern your test classes can simply extend GroovyTestCase as they will not interact directly with Selenium.
<h2><a name="2.4. Using Other Testing Frameworks">2.4. Using Other Testing Frameworks</a></h2>Selenium tests do not have to be written as JUnit test cases. Theoretically the <code>SeleniumTest</code> mixin could be applied to
almost any test case written in another framework. Page objects are also agnostic of the test framework.<p class="paragraph"/>Currently the plugin has tested support for the
<a href="http://grails.org/plugin/spock" target="blank">Spock Plugin</a>. Other testing frameworks such as EasyB, TestNG, JUnit 4, etc. may well work already and support
is planned in future versions of the Selenium plugin.<p class="paragraph"/>To write Selenium tests using Spock, simply create your specification under <code>test/selenium</code> and (if you are not using page objects) use the <code>SeleniumTest</code> mixin then run tests as normal. For example:
<div class="code"><pre><span class="java&#45;keyword">import</span> spock.lang.&#42;
<span class="java&#45;keyword">import</span> grails.plugins.selenium.&#42;<p class="paragraph"/>@Mixin(SeleniumTest)
class HomepageSpecification <span class="java&#45;keyword">extends</span> Specification &#123;
    def <span class="java&#45;quote">"user can load application homepage"</span>() &#123;
        when:
            selenium.open(contextPath)
        then:
            selenium.isTextPresent(<span class="java&#45;quote">"Welcome to Grails"</span>)
    &#125;
&#125;</pre></div><p class="paragraph"/>You can isolate Spock Selenium tests with <code>grails test-app :spock-selenium</code> or <code>grails test-app functional:spock-selenium</code> just as you can for other test types. 

	</body>
</html>