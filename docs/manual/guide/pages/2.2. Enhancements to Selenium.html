<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>2.2. Enhancements to Selenium</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		The <code>selenium</code> property provided by the <code>SeleniumAware</code> mixin is actually an extension of the standard <a href="http://release.seleniumhq.org/selenium-remote-control/1.0-beta-2/doc/java/com/thoughtworks/selenium/Selenium.html" target="blank">Selenium</a> object that enhances it in a number of ways.<p class="paragraph"/><h3>waitFor*</h3>
<ul class="star">
<li>Any <em class="italic">is&#42;</em> methods in <code>Selenium</code> have an equivalent <em class="italic">waitFor</em> taking the same parameters</li>
<li>Any <em class="italic">get&#42;</em> methods in <code>Selenium</code> have an equivalent <em class="italic">waitFor</em> taking the same parameters plus an <em class="italic">'expectation'</em> String</li>
<li>Any <em class="italic">get&#42;</em> methods in <code>Selenium</code> have an equivalent <em class="italic">waitFor</em> taking the same parameters plus a <code>java.util.Pattern</code></li>
<li>Any <em class="italic">get&#42;</em> methods in <code>Selenium</code> have an equivalent <em class="italic">waitFor</em> taking the same parameters plus a <a href="http://code.google.com/p/hamcrest/" target="blank">Hamcrest Matcher</a></li>
</ul><p class="paragraph"/><div class="code"><pre>// waitFor&#42; equivalents of is&#42; methods
selenium.isAlertPresent()
selenium.waitForAlertPresent()<p class="paragraph"/>selenium.isTextPresent(<span class="java&#45;quote">"My Title"</span>)
selenium.waitForTextPresent(<span class="java&#45;quote">"My Title"</span>)<p class="paragraph"/>// waitFor&#42; equivalents of get&#42; methods
selenium.getAlert() == <span class="java&#45;quote">"Error"</span>
selenium.waitForAlert(<span class="java&#45;quote">"Error"</span>)<p class="paragraph"/>selenium.getText(<span class="java&#45;quote">"css=h1"</span>) == <span class="java&#45;quote">"My Title"</span>
selenium.waitForText(<span class="java&#45;quote">"css=h1"</span>, <span class="java&#45;quote">"My Title"</span>)<p class="paragraph"/>// waitFor&#42; with Pattern
selenium.getText(<span class="java&#45;quote">"css=h1"</span>) ==~ ~/&#119;+ Title/
selenium.waitForText(<span class="java&#45;quote">"css=h1"</span>, ~/&#119;+ Title/) // note: <span class="java&#45;keyword">this</span> is a compiled regex pattern with a leading ~<p class="paragraph"/>// waitFor&#42; with Hamcrest Matchers
selenium.waitForText(<span class="java&#45;quote">"css=h1"</span>, equalTo(<span class="java&#45;quote">"My Title"</span>))</pre></div><p class="paragraph"/><h3>waitForNot*</h3><p class="paragraph"/>Any time you can use <em class="italic">waitFor&#42;</em> you can also use <em class="italic">waitForNot&#42;</em> except when using a Hamcrest Matcher (in which case you would simply use the <em class="italic">not</em> Matcher). For example:<p class="paragraph"/><div class="code"><pre>selenium.waitForNotVisible(<span class="java&#45;quote">"css=.panel"</span>)
selenium.waitForNotText(<span class="java&#45;quote">"css=h1"</span>, <span class="java&#45;quote">"My Title"</span>)<p class="paragraph"/>// Hamcrest has its own negation matcher, so waitForNot&#42; isn't supported
selenium.waitForText(not(equalTo(<span class="java&#45;quote">"My Title"</span>)))</pre></div><p class="paragraph"/><h3>waitFor(String, Closure)</h3><p class="paragraph"/>You can also wait for arbitrary conditions using the <em class="italic">waitFor</em> method passing a message and a closure that returns a <em class="italic">boolean</em> value. For example:<p class="paragraph"/><div class="code"><pre>selenium.click(<span class="java&#45;quote">"myButton"</span>)
selenium.waitFor(<span class="java&#45;quote">"Clicking myButtonId should have updated myDiv via AJAX"</span>) &#123;
    selenium.getText(<span class="java&#45;quote">"myDiv"</span>) == <span class="java&#45;quote">"Some value"</span>
&#125;</pre></div><p class="paragraph"/>The <code>waitFor</code> method will fail if the expected condition does not hold true after the default timeout.<p class="paragraph"/><h3>*AndWait</h3><p class="paragraph"/>Any method can be appended with <em class="italic">AndWait</em> so that it will wait for the page to load before returning. Obviously this only makes sense on commands that trigger a page load. For example <code>selenium.clickAndWait("css=input.myButton")</code> will click the button <em class="italic">"myButton"</em> and then wait for a new page to finish loading.<p class="paragraph"/><blockquote class="note">
It is <em class="italic">not</em> necessary to add <em class="italic">AndWait</em> to the <code>open()</code> command as it already waits for the page to finish loading before returning. Also be aware that <em class="italic">AndWait</em> does <em class="italic">not</em> wait for AJAX events. To handle AJAX updates to the page you should wait for a condition such as an element appearing or some text changing.
</blockquote><p class="paragraph"/><h3>waitForPageToLoad()</h3><p class="paragraph"/>The method <code>waitForPageToLoad(String)</code> has an overridden version that requires no arguments and will use the timeout set using <code>setTimeout</code> or the default timeout specified in configuration.<p class="paragraph"/><h3>JavaScript user extensions</h3><p class="paragraph"/>Any <em class="italic">do&#42;</em> or <em class="italic">get&#42;</em> functions you have defined in a JavaScript user extensions file can be invoked directly from your Groovy code. The <em class="italic">do</em> prefix should be dropped on action function calls. This is consistent with how the <a href="http://seleniumhq.org/projects/ide/" target="blank">Selenium IDE</a> handles user extensions.<p class="paragraph"/><h4>User extension definitions in JavaScript</h4><p class="paragraph"/><div class="code"><pre>Selenium.prototype.doLogin = function(username, password) &#123;
	<span class="java&#45;keyword">this</span>.doType(<span class="java&#45;quote">"css=input&#91;name=j_username&#93;"</span>, username);
	<span class="java&#45;keyword">this</span>.doType(<span class="java&#45;quote">"css=input&#91;name=j_password&#93;"</span>, password);
	<span class="java&#45;keyword">this</span>.doClick(<span class="java&#45;quote">"css=input&#91;type=submit&#93;"</span>);
	<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">this</span>.doWaitForPageToLoad(<span class="java&#45;keyword">this</span>.defaultTimeout);
&#125;<p class="paragraph"/>Selenium.prototype.getLoginState = function(locator) &#123;
	<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">this</span>.getText(<span class="java&#45;quote">"css=.loginInfo"</span>);
&#125;;</pre></div><p class="paragraph"/><h4>Calling user extensions from Groovy</h4><p class="paragraph"/><div class="code"><pre>void testUserCanLogIn() &#123;
	selenium.open <span class="java&#45;quote">"/"</span>
	assertEquals <span class="java&#45;quote">"Not logged in"</span>, selenium.loginState<p class="paragraph"/>	selenium.open <span class="java&#45;quote">"/login"</span>
	selenium.login(<span class="java&#45;quote">"rob"</span>, <span class="java&#45;quote">"password"</span>)
	assertEquals <span class="java&#45;quote">"Logged in as rob"</span>, selenium.loginState
&#125;</pre></div>

	</body>
</html>