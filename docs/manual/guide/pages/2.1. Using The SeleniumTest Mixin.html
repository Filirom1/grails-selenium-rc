<html>
     <head>
     	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
     	<title>2.1. Using The SeleniumTest Mixin</title>
     	<link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8">
     </head>
	<body class="body">
		The simplest way to write Selenium tests is to create a class that extends <code>GroovyTestCase</code> and add the <code>SeleniumTest</code>
mixin that the plugin provides. The mixin class makes several properties and methods available, the most crucial of
which is the running <code>Selenium</code> instance. For example:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">import</span> grails.plugins.selenium.SeleniumTest<p class="paragraph"/>@Mixin(SeleniumTest)
class HomepageTests <span class="java&#45;keyword">extends</span> GroovyTestCase &#123;
    void testHomepageLoads() &#123;
        selenium.open <span class="java&#45;quote">"$contextPath/"</span>
        assertTrue selenium.isTextPresent(<span class="java&#45;quote">"Welcome to Grails"</span>)
    &#125;
&#125;</pre></div><p class="paragraph"/>References to the <code>selenium</code> property in the test will get the running <code>Selenium</code> instance from the mixin class. You
might also notice the <code>contextPath</code> property used in the <code>open</code> call. This is also provided by the mixin class and is a
reference to the context that your application is running under.<p class="paragraph"/><h3>Properties and methods of the SeleniumTest mixin</h3>
<table class="wiki-table" cellpadding="0" cellspacing="0" border="0"><tr><th><strong class="bold">Name</strong></th><th><strong class="bold">Description</strong></th></tr><tr class="table-odd"><td>selenium</td><td>The running Selenium instance that is used to interact with the browser.</td></tr><tr class="table-even"><td>contextPath</td><td>The URL context path of the application under test. This needs to be prepended to all URLs you open with selenium.</td></tr><tr class="table-odd"><td>config</td><td>The Selenium configuration object.</td></tr><tr class="table-even"><td>waitFor(String, Closure)</td><td>A method that allows your test to wait for some condition to become true.</td></tr></table><p class="paragraph"/><h3>Using the waitFor method</h3>
The <code>waitFor</code> method is particularly useful when testing rich UIs where clicks do not cause the entire page to refresh
but instead trigger AJAX actions that update portions of the page asynchronously. For example to click a button then
wait for some text to appear before proceeding:<p class="paragraph"/><div class="code"><pre>selenium.click(<span class="java&#45;quote">"myButton"</span>)
waitFor(<span class="java&#45;quote">"Clicking myButtonId should have updated myDiv via AJAX"</span>) &#123;
    selenium.getText(<span class="java&#45;quote">"myDiv"</span>) == <span class="java&#45;quote">"Some value"</span>
&#125;</pre></div><p class="paragraph"/>The <code>waitFor</code> method will fail if the expected condition does not hold true after the default timeout specified with
<code>selenium.defaultTimeout</code> in your <code>SeleniumConfig.groovy</code> file or 60 seconds if you have not specified a value.<p class="paragraph"/>The message argument is optional but greatly assists in analysing test failures so it is recommended that you always
provide it.

	</body>
</html>