Regardless of whether you are using page objects, the @SeleniumTest@ mixin or extending @GrailsSeleniumTestCase@ at some point you will be writing code to interact with Selenium itself. The plugin enhances the standard @[Selenium|http://release.seleniumhq.org/selenium-remote-control/1.0-beta-2/doc/java/com/thoughtworks/selenium/Selenium.html]@ object in a number of ways.

 * Any Selenium method starting with @is@ has an equivalent @waitFor@ taking the same parameters. For example, to test that the text "My Title" appears on the page you would use @selenium.isTextPresent("MyTitle")@. The plugin adds the ability to wait until that text appears using @selenium.waitForTextPresent("My Title")@.
 * Any method starting with @get@ has an equivalent @waitFor@ taking the same parameters plus an 'expectation' String. For example to test that the text "My Title" appears in the page's header you would use @selenium.getText("css=h1") == "My Title"@. The plugin allows you to wait for that condition using @selenium.waitForText("css=h1", "My Title")@.
 * The method @[waitForPageToLoad|http://release.seleniumhq.org/selenium-remote-control/1.0-beta-2/doc/java/com/thoughtworks/selenium/Selenium.html#waitForPageToLoad(java.lang.String)]@ can be called with no arguments and will use the default timeout specified in configuration.
 * Any method can be appended with @AndWait@ so that it will wait for the page to load before returning. Obviously this only makes sense on commands that trigger a page load. For example @selenium.clickAndWait("css=input.myButton")@ will click the button "myButton" and then wait for a new page to finish loading.

{note}
It is _not_ necessary to add @AndWait@ to the @open@ command as it already waits for the page to finish loading before returning. Also be aware that @AndWait@ does _not_ wait for AJAX events. To handle AJAX updates to the page you should wait for a condition such as an element appearing or some text changing.
{note}

