Whether using the @SeleniumTest@ mixin or extending @GrailsSeleniumTestCase@ your tests interact directly with Selenium. Once you go beyond a handful of simple tests this can make your tests difficult to maintain as they are dealing with the details of the page. Some of the problems with this approach include:
 * Page element locators (whether XPath, CSS, element Ids, etc.) are repeated throughout the tests and therefore require you to hunt out instances if you change the page structure.
 * Multiple Selenium commands representing a single _logical_ action may be repeated in several tests or grouped together into utility classes that can easily get out of control and turn into 'God Objects'.

To truly decouple the functional intent of your tests from the raw Selenium interactions you can write 'page objects'. A page object represents a particular page within your application and defines methods and properties that allow your tests to interact with the page. The tests interact with the page objects, not directly with Selenium so they operate at a layer of abstraction from the fine details of the page. The advantages of this pattern include:
 * Details of page can be refactored more easily as changes only need to be reflected in the page object, not the tests themselves.
 * Complex interactions can be modelled in methods on the page object, meaning they can be reused in multiple tests.
 * Navigation actions can be modelled as page object methods that return instances of other page objects representing the user's journey through the application.
 * Page objects are very easy to write, can be expanded as necessary and greatly enhance the simplicity and readability of your tests.

When using the page object pattern your test classes can simply extend GroovyTestCase as they will not interact directly with Selenium.

h2. Page object support in the plugin
The plugin provides some base classes for page objects. These can be used as-is for simple scenarios or extended (or ignored completely of course). All the classes are in the @grails.plugins.selenium.pageobjects@ package. Refer to the API documentation for more details.
 * @Page@ is the root of the page object heirarchy.
 * @GrailsPage@ and @GrailsFormPage@ are extended by classes representing the various typical scaffolding pages.
 * @GrailsListPage@ represents a scaffolded _list_ page and provides easy access to data in a list table, access to the pagination controls, etc.
 * @GrailsShowPage@ represents a scaffolded _show_ page and provides property access to data in a typical _show_ page.
 * @GrailsCreatePage@ and @GrailsEditPage@ represent scaffolded _create_ and _edit_ pages and translate @page.field = "value"@ type calls to Selenium commands that type in form fields.

h3. Extending the plugin's base page object classes
TODO